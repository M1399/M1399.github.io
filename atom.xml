<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yangq blog</title>
  
  <subtitle>My First、Study、Summary、Insist and Efforts</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yangqingwt.top/"/>
  <updated>2018-04-21T10:53:24.129Z</updated>
  <id>http://www.yangqingwt.top/</id>
  
  <author>
    <name>Yangq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis</title>
    <link href="http://www.yangqingwt.top/2018/04/21/redis/"/>
    <id>http://www.yangqingwt.top/2018/04/21/redis/</id>
    <published>2018-04-21T10:19:42.000Z</published>
    <updated>2018-04-21T10:53:24.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h2><ul><li>Redis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。</li><li>优点<ul><li>快</li><li>支持丰富的数据类型</li><li>操作具有原子性</li><li>多实用工具，用例：缓存、消息队列（Redis本地支持发布订阅）、应用程序中的任何短期数据：web应用程序中的会话、网页命中计数等</li></ul></li></ul><a id="more"></a><ul><li>Redis与其他键值存储系统<ul><li>Redis是键值数据库系统的不同进化路线，它的值可以包含更复杂的数据类型，可在这些数据类型上定义原子操作。</li><li>Redis是一个内存数据库，但在磁盘数据库上是持久的，因此它代表了一个不同的权衡，在这种情况下，在不能大于存储器(内存)的数据集的限制下实现非常高的写和读速度。</li><li>内存数据库的另一个优点是，它与磁盘上的相同数据结构相比，复杂数据结构在内存中存储表示更容易操作。 因此，Redis可以做很少的内部复杂性。</li></ul></li></ul><ol><li>安装：<ul><li>brew install redis-server</li></ul></li><li><p>启动：</p><ul><li>redis-server</li><li><p>redis-cli # 检查Redis是否正在工作（进入Redis数据库）</p><ul><li><p>获取所有配置设置</p><blockquote><p>CONFIG GET * </p></blockquote></li><li><p>支持的数据类型：字符串、散列/哈希、列表、集合、可排序集合</p></li><li><p>检查服务器是否正在运行</p><blockquote><p>PING</p></blockquote></li><li><p>连接远程服务器：</p><blockquote><p>redis-cli -h host -p port -a password</p></blockquote></li></ul></li></ul></li></ol><h2 id="redia实现消息队列"><a href="#redia实现消息队列" class="headerlink" title="redia实现消息队列"></a>redia实现消息队列</h2><ul><li>生产者消费者模式：让一个或多个客户端监听消息队列，一旦消息到达，消费者马上消费，谁抢到算谁，如果队列没有消息，则消费者继续监听。</li><li>发布订阅者模式：一个或多个客户端订阅消息频道，只要发布者发布消息，所有订阅者都能收到消息，订阅者都是ping的。</li></ul><h3 id="生产消费模式"><a href="#生产消费模式" class="headerlink" title="生产消费模式"></a>生产消费模式</h3><p>blpop获取队列数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">&quot;&quot;&quot;</div><div class="line">生产者-消费者模式中的消费者</div><div class="line">&quot;&quot;&quot;</div><div class="line">import redis</div><div class="line"></div><div class="line">class Task(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.rcon = redis.StrictRedis(host=&apos;localhost&apos;, db=5)</div><div class="line">        self.queue = &apos;task:prodcons:queue&apos;</div><div class="line"></div><div class="line">    def listen_task(self):</div><div class="line">        while True:</div><div class="line">            task = self.rcon.blpop(self.queue, 0)[1]</div><div class="line">            print &quot;Task get&quot;, task</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    print &apos;监听任务队列&apos;</div><div class="line">    Task().listen_task()</div></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>pubsub功能，订阅者订阅频道，发布者发布消息到频道了，频道就是一个消息队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div><div class="line">&quot;&quot;&quot;</div><div class="line">发布订阅模式中的订阅者</div><div class="line">&quot;&quot;&quot;</div><div class="line">import redis</div><div class="line"></div><div class="line">class Task(object):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.rcon = redis.StrictRedis(host=&apos;localhost&apos;, db=5)</div><div class="line">        self.ps = self.rcon.pubsub()</div><div class="line">        self.ps.subscribe(&apos;task:pubsub:channel&apos;)</div><div class="line"></div><div class="line">    def listen_task(self):</div><div class="line">        for i in self.ps.listen():</div><div class="line">            if i[&apos;type&apos;] == &apos;message&apos;:</div><div class="line">                print &quot;Task get&quot;, i[&apos;data&apos;]</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    print &apos;监听任务频道&apos;</div><div class="line">    Task().listen_task()</div></pre></td></tr></table></figure><h3 id="提供生产者和消息发布者"><a href="#提供生产者和消息发布者" class="headerlink" title="提供生产者和消息发布者"></a>提供生产者和消息发布者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">&quot;&quot;&quot;</div><div class="line">提供一个页面作为生产者/消息发布者</div><div class="line">&quot;&quot;&quot;</div><div class="line">import redis</div><div class="line">import random</div><div class="line">import logging</div><div class="line">from flask import Flask, redirect</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">rcon = redis.StrictRedis(host=&apos;localhost&apos;, db=1)</div><div class="line">prodcons_queue = &apos;task:prodcons:queue&apos;  #生产者消费者队列名称</div><div class="line">pubsub_channel = &apos;task:pubsub:channel&apos; #发布订阅频道名称</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line"></div><div class="line">    html = &quot;&quot;&quot;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;center&gt;&lt;h3&gt;Redis Message Queue&lt;/h3&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;a href=&quot;/prodcons&quot;&gt;生产消费者模式&lt;/a&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;a href=&quot;/pubsub&quot;&gt;发布订阅者模式&lt;/a&gt;</div><div class="line">&lt;/center&gt;</div><div class="line">&quot;&quot;&quot;</div><div class="line">    return html</div><div class="line"></div><div class="line">#生产者</div><div class="line">@app.route(&apos;/prodcons&apos;)</div><div class="line">def prodcons():</div><div class="line">    elem = random.randrange(10)</div><div class="line">    rcon.lpush(prodcons_queue, elem)</div><div class="line">    logging.info(&quot;lpush &#123;&#125; -- &#123;&#125;&quot;.format(prodcons_queue, elem))</div><div class="line">    return redirect(&apos;/&apos;)</div><div class="line">#消息发布者</div><div class="line">@app.route(&apos;/pubsub&apos;)</div><div class="line">def pubsub():</div><div class="line">    ps = rcon.pubsub()</div><div class="line">    ps.subscribe(pubsub_channel)</div><div class="line">    elem = random.randrange(10)</div><div class="line">    rcon.publish(pubsub_channel, elem)</div><div class="line">    return redirect(&apos;/&apos;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    app.run(debug=True)</div></pre></td></tr></table></figure><p>原文地址：<br><a href="https://www.yiibai.com/redis/redis_quick_guide.html" target="_blank" rel="external">https://www.yiibai.com/redis/redis_quick_guide.html</a><br><a href="http://www.cnblogs.com/taceywong/p/5843944.html" target="_blank" rel="external">http://www.cnblogs.com/taceywong/p/5843944.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis基础&quot;&gt;&lt;a href=&quot;#redis基础&quot; class=&quot;headerlink&quot; title=&quot;redis基础&quot;&gt;&lt;/a&gt;redis基础&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Redis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。&lt;/li&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;快&lt;/li&gt;
&lt;li&gt;支持丰富的数据类型&lt;/li&gt;
&lt;li&gt;操作具有原子性&lt;/li&gt;
&lt;li&gt;多实用工具，用例：缓存、消息队列（Redis本地支持发布订阅）、应用程序中的任何短期数据：web应用程序中的会话、网页命中计数等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>uWSGI</title>
    <link href="http://www.yangqingwt.top/2018/04/21/uWSGI/"/>
    <id>http://www.yangqingwt.top/2018/04/21/uWSGI/</id>
    <published>2018-04-21T09:01:38.000Z</published>
    <updated>2018-04-21T10:15:14.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><ul><li>WSGI：一种描述web server如何与web application通信的规范，当前运行在WSGI协议之上的web框架有Bottle、Flask、Django。</li><li>uwsgi: uWSGI服务器的独占协议，用于定义传输信息的类型，每一个uwsgi packet前4byte为传输信息类型的描述。该协议是fcgi协议的10倍快。</li><li>uWSGI：web服务器，实现了WSGI协议、uwsgi协议、http协议等。<ul><li>超快性能、低内存占用、多app管理、详尽的日志功能、高度可定制</li><li>uWSGI自己实现了基于uwsgi协议的server部分，只需在uwsgi的配置中指定application地址，uWSGI就能直接和应用框架中的WSGI application通信</li></ul></li></ul><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><ul><li>有多种方法安装</li></ul><ol><li>pip install uwsgi</li><li>使用网络安装器下载安装</li></ol><blockquote><p><a href="http://uwsgi.it/install" target="_blank" rel="external">http://uwsgi.it/install</a> | bash -s default /tmp/uwsgi</p></blockquote><ol><li>通过下载源tarball文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz</div><div class="line">2. tar zxvf uwsgi-latest.tar.gz</div><div class="line">3. cd uwsgi-latest</div><div class="line">4. make</div></pre></td></tr></table></figure><h3 id="2-部署在HTTP端口"><a href="#2-部署在HTTP端口" class="headerlink" title="2. 部署在HTTP端口"></a>2. 部署在HTTP端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uwsgi --http :3031 --wsgi-file file.py --master --processes 4 --threads 2 --stats 127.0.0.1:3031</div><div class="line">uwsgi -s :3031 -w file.py -p 4 -t 2</div></pre></td></tr></table></figure><ul><li>–processes 4 生成4个进程</li><li>–threads 2 每个进程2个线程</li><li>stats子系统允许你将uWSGI的内部统计数据作为JSON导出</li></ul><ul><li>如果你的代理/web服务器/路由器使用HTTP，那么你必须告诉uWSGI本地使用http协议 (这与会自己生成一个代理的–http不同):</li></ul><blockquote><p>uwsgi –http-socket 127.0.0.1:3031 –wsgi-file foobar.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191</p></blockquote><h3 id="3-部署Django"><a href="#3-部署Django" class="headerlink" title="3. 部署Django"></a>3. 部署Django</h3><blockquote><p>uwsgi –socket 127.0.0.1:3031 –chdir dir/diango –wsgi-file wsgi.py –master –processes 4 –threads 2 –stats 127.0.0.1:9091</p></blockquote><ul><li>–chdir 移到指定的目录下，在Django中，需要这样来正确加载模块</li><li>这样的长命令，累赘又麻烦愚蠢，容易犯错==，丢掉丢掉，使用.ini文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">socket = 127.0.0.1:3031</div><div class="line">chdir = dir/diango</div><div class="line">wsgi-file = wsgi.py</div><div class="line">processes = 4</div><div class="line">thread = 2</div><div class="line">stats = 127.0.0.1:9091</div></pre></td></tr></table></figure><ul><li>运行 uwsgi config.ini</li></ul><h3 id="4-部署Flask"><a href="#4-部署Flask" class="headerlink" title="4. 部署Flask"></a>4. 部署Flask</h3><ul><li>flask.py</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">return &quot;&lt;span style=&apos;color:blue&apos;&gt;lalala, test flask&lt;/span&gt;&quot;</div></pre></td></tr></table></figure><ul><li>WSGI函数application导出为app，需要指示uWSGI使用它<ul><li>-callable app</li></ul></li></ul><h3 id="5-python线程注意事项"><a href="#5-python线程注意事项" class="headerlink" title="5. python线程注意事项"></a>5. python线程注意事项</h3><ul><li>不适用线程的情况下启动uWSGI，python GIL（全局锁）将不会启动，因此你的应用生成的线程将不会运行。</li><li><p>如果想维护python线程支持，而不为你的应用启动多线程，添加–enable-threads选项</p><ul><li>enable-threads = true    (.ini文件)</li></ul></li></ul><p>原文链接：</p><p><a href="https://www.jianshu.com/p/679dee0a4193" target="_blank" rel="external">https://www.jianshu.com/p/679dee0a4193</a><br><a href="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html" target="_blank" rel="external">http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/WSGIquickstart.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;WSGI：一种描述web server如何与web application通信的规范，当前运行在WSGI协议之上的web框架有Bottle、Flask、Django。&lt;/li&gt;
&lt;li&gt;uwsgi: uWSGI服务器的独占协议，用于定义传输信息的类型，每一个uwsgi packet前4byte为传输信息类型的描述。该协议是fcgi协议的10倍快。&lt;/li&gt;
&lt;li&gt;uWSGI：web服务器，实现了WSGI协议、uwsgi协议、http协议等。&lt;ul&gt;
&lt;li&gt;超快性能、低内存占用、多app管理、详尽的日志功能、高度可定制&lt;/li&gt;
&lt;li&gt;uWSGI自己实现了基于uwsgi协议的server部分，只需在uwsgi的配置中指定application地址，uWSGI就能直接和应用框架中的WSGI application通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://www.yangqingwt.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="web服务器" scheme="http://www.yangqingwt.top/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>黑产资源收集</title>
    <link href="http://www.yangqingwt.top/2017/10/23/%E9%BB%91%E4%BA%A7%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86/"/>
    <id>http://www.yangqingwt.top/2017/10/23/黑产资源收集/</id>
    <published>2017-10-23T09:40:24.000Z</published>
    <updated>2017-10-23T16:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑产"><a href="#黑产" class="headerlink" title="黑产"></a>黑产</h1><h2 id="收集目标为三大类：打码接码平台、云控群控平台、套现中介。"><a href="#收集目标为三大类：打码接码平台、云控群控平台、套现中介。" class="headerlink" title="收集目标为三大类：打码接码平台、云控群控平台、套现中介。"></a>收集目标为三大类：打码接码平台、云控群控平台、套现中介。</h2><h3 id="打码、接码"><a href="#打码、接码" class="headerlink" title="打码、接码"></a>打码、接码</h3><h4 id="打码"><a href="#打码" class="headerlink" title="打码"></a>打码</h4><ul><li><p>打码平台，就是打验证码。很多软件需要输入验证码后才能登陆。</p></li><li><p>程序将验证码传给打码平台的识别接口，打码平台将验证码发给后端的“打码工”进行识别，并获取识别结果。这样基于此类的人工打码平台，即可实现程序的自动化。</p></li><li><p>例子：羊毛党要去某网站刷活动优惠券，但该网站有较复杂的图像验证码。通常羊毛党会在打码平台注册账号并充值，并通过打码平台提供的api接口，提交验证码识别。打码平台将验证码分发到各个佣工的客户端里，获取佣工的识别结果，并最终反馈给羊毛党。</p></li><li>打码平台普通的四位验证码0.6~1分钱，语音平台一元一条，接码0.1一条</li></ul><h4 id="接码平台"><a href="#接码平台" class="headerlink" title="接码平台"></a>接码平台</h4><ul><li>接码平台就是接受验证码。当注册某平台，不想用自己手机号或者自己手机号已经用过了，就可以利用接码平台，获取验证码，进行注册。</li><li>接码平台，提供大量的手机号，并能够发送和接收短信。只需调用手机打码平台相关接口，获取手机号并获取短信内容即可进行批量注册。</li></ul><h3 id="云控、群控"><a href="#云控、群控" class="headerlink" title="云控、群控"></a>云控、群控</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑产&quot;&gt;&lt;a href=&quot;#黑产&quot; class=&quot;headerlink&quot; title=&quot;黑产&quot;&gt;&lt;/a&gt;黑产&lt;/h1&gt;&lt;h2 id=&quot;收集目标为三大类：打码接码平台、云控群控平台、套现中介。&quot;&gt;&lt;a href=&quot;#收集目标为三大类：打码接码平台、云控群控平台、套现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python之map、filter、reduce</title>
    <link href="http://www.yangqingwt.top/2017/10/23/python%E4%B9%8Bmap%E3%80%81filter%E3%80%81reduce/"/>
    <id>http://www.yangqingwt.top/2017/10/23/python之map、filter、reduce/</id>
    <published>2017-10-23T08:11:57.000Z</published>
    <updated>2017-10-24T08:23:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li>Map会将一个函数映射到一个输入列表的所有元素上</li><li>规范：map(function_to_apply, list_of_imputs)</li><li>把列表中所有元素一个个传递给一个函数，并收集输出<br>  <img src="/img/python/map1.png" alt=""></li></ul><a id="more"></a><ul><li><p>使用map<br><img src="/img/python/map2.png" alt=""></p></li><li><p>使用匿名函数lambda来配合map<br>  <img src="/img/python/map3.png" alt=""></p><ul><li>print加了list转换，是为了python2/3的兼容性</li><li>在python2中map直接返回列表，但python3返回迭代器</li></ul></li></ul><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><ul><li><p>filter过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表。<br><img src="/img/python/filter.png" alt=""></p></li><li><p>filter类似于一个for循环，但它是一个内置函数，并且更快</p></li></ul><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><ul><li>reduce：对列表进行计算并返回结果</li><li>例：计算一个整数列表的乘积<br><img src="/img/python/reduce.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Map会将一个函数映射到一个输入列表的所有元素上&lt;/li&gt;
&lt;li&gt;规范：map(function_to_apply, list_of_imputs)&lt;/li&gt;
&lt;li&gt;把列表中所有元素一个个传递给一个函数，并收集输出&lt;br&gt;  &lt;img src=&quot;/img/python/map1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.yangqingwt.top/categories/python/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux之cut</title>
    <link href="http://www.yangqingwt.top/2017/10/17/Linux%E4%B9%8Bcut/"/>
    <id>http://www.yangqingwt.top/2017/10/17/Linux之cut/</id>
    <published>2017-10-17T08:08:19.000Z</published>
    <updated>2017-10-17T08:08:19.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Collections</title>
    <link href="http://www.yangqingwt.top/2017/09/21/Collections/"/>
    <id>http://www.yangqingwt.top/2017/09/21/Collections/</id>
    <published>2017-09-21T10:29:01.000Z</published>
    <updated>2017-09-24T01:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collections是什么"><a href="#Collections是什么" class="headerlink" title="Collections是什么"></a>Collections是什么</h2><p>Collections是python内建的一个集合模块，提供了许多有用的集合类</p><h2 id="提供的集合类"><a href="#提供的集合类" class="headerlink" title="提供的集合类"></a>提供的集合类</h2><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><blockquote><p>from collections import defaultdict</p></blockquote><h3 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h3><ul><li><p>计数器，可以针对某项数据进行计数</p><pre><code>&gt; from collections import Counter&gt; colours = (    (&apos;Yasoob&apos;, &apos;Yellow&apos;),    (&apos;Ali&apos;, &apos;Blue&apos;),    (&apos;Arham&apos;, &apos;Green&apos;),    (&apos;Ali&apos;, &apos;Black&apos;),    (&apos;Yasoob&apos;, &apos;Red&apos;),    (&apos;Ahmed&apos;, &apos;Silver&apos;),)&gt; favs = Counter(name for name, colour in colours)&gt; print(favs)## 输出:## Counter({##     &apos;Yasoob&apos;: 2,##     &apos;Ali&apos;: 2,##     &apos;Arham&apos;: 1,##     &apos;Ahmed&apos;: 1##  })</code></pre></li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><ul><li>它提供了一个双端队列，可以从头或尾两端添加或删除元素</li><li><p>用法类型python的list</p><pre><code>&gt; from collections import deque&gt; d = deque()&gt; d.append(&apos;1&apos;)&gt; d.append(&apos;2&apos;)&gt; d.append(&apos;3&apos;）&gt; print(len(d))... 3&gt; print(d[0])... 1</code></pre></li><li><p>可以从两端取出(pop)数据：</p><pre><code>&gt; d = deque（range(5))&gt; print(len(d))... 5&gt; d.popleft()... 0&gt; d.pop()... 4&gt; print(d)... deque([1, 2, 3])</code></pre></li><li><p>可以限制这个列表的大小，当超出你设定的限制时，数据会从对队列另一端被挤出去(pop)</p><pre><code>d = deque(maxlen=30)</code></pre></li><li><p>可以从任一端扩展这个队列中的数据：</p><pre><code>&gt; d = deque([1,2,3,4,5])&gt; d.extendleft([0])&gt; d.extend([6,7,8])&gt; print(d)... deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</code></pre></li></ul><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul><li>一个元组是一个不可变的列表，你可以存储一个数据的序列，它和命名元组(namedtuples)非常像，但有几个关键的不同。</li><li><p>主要相似点: </p><ul><li>不能修改元组中的数据。</li><li><p>获取元组中的数据，需要使用整数作为索引：</p><pre><code>&gt; man = (&apos;Ali&apos;, 30)&gt; print(man[0])... Ali</code></pre></li></ul></li></ul><h4 id="命名元组"><a href="#命名元组" class="headerlink" title="命名元组"></a>命名元组</h4><ul><li><p>namedtuples: 把元组变成一个针对简单任务的容器。</p><ul><li>可以像字典一样访问namedtuples</li><li><p>但namedtuples是不可变的。</p><pre><code>&gt; from collections import namedtuple&gt; Animal = namedtuple(&apos;Animal&apos;, &apos;name age type&apos;)&gt; perry = Animal(name=&quot;perry&quot;, age=31, type=&quot;cat&quot;)&gt; print(perry)... Animal(name=&apos;perry&apos;, age=31, type=&apos;cat&apos;)&gt; print(perry.name)... &apos;perry&apos;</code></pre></li><li><p>上例中，元组名称是Animal，字段名称是’name’，’age’和’type’。</p></li></ul></li><li>namedtuple优点：<ul><li>让你的元组变得自文档了。你只要看一眼就很容易理解代码是做什么的</li><li>你也不必使用整数索引来访问一个命名元组，这让你的代码更易于维护。</li><li>namedtuple的每个实例没有对象字典，所以它们很轻量，与普通的元组比，并不需要更多的内存。这使得它们比字典更快。</li></ul></li><li><p>可以将命名元祖转化为字典</p><pre><code>&gt; from collections import namedtuple&gt; Animal = namedtuple(&apos;Animal&apos;, &apos;name age type&apos;)&gt; perry = Animal(name=&quot;Perry&quot;, age=31, type=&quot;cat&quot;)&gt; print(perry._asdict())... OrderedDict([(&apos;name&apos;, &apos;Perry&apos;), (&apos;age&apos;, 31), (&apos;type&apos;, &apos;cat&apos;)])</code></pre></li></ul><h3 id="enum-Enum-Python-3-4"><a href="#enum-Enum-Python-3-4" class="headerlink" title="enum.Enum (Python 3.4+)"></a>enum.Enum (Python 3.4+)</h3><p>枚举对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Collections是什么&quot;&gt;&lt;a href=&quot;#Collections是什么&quot; class=&quot;headerlink&quot; title=&quot;Collections是什么&quot;&gt;&lt;/a&gt;Collections是什么&lt;/h2&gt;&lt;p&gt;Collections是python内建的一
      
    
    </summary>
    
      <category term="python内建模块" scheme="http://www.yangqingwt.top/categories/python%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>virtualenv</title>
    <link href="http://www.yangqingwt.top/2017/09/21/virtualenv/"/>
    <id>http://www.yangqingwt.top/2017/09/21/virtualenv/</id>
    <published>2017-09-21T10:02:59.000Z</published>
    <updated>2017-09-21T10:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="virtualenv是什么"><a href="#virtualenv是什么" class="headerlink" title="virtualenv是什么"></a>virtualenv是什么</h2><ul><li>virtualenv是一个工具，能够创建一个独立的python环境</li></ul><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote><p>pip install virtualenv</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1). 创建一个隔离的virtualenv环境</p><blockquote><p>virtualenv project</p></blockquote><a id="more"></a><ul><li>让virtualenv使用全局模块</li></ul><blockquote><p>virtualenv –system-site-packages project</p></blockquote><ul><li>第三方包不复制，得到不带任何第三方包的“干净”的Python运行环境</li></ul><blockquote><p>virtualenv —no-site-packages project</p></blockquote><p>2). 激活环境</p><blockquote><p>source myproject/bin/activate</p></blockquote><p>3). 退出虚拟环境</p><blockquote><p>deactivate</p></blockquote><p>4). 删除虚拟环境</p><blockquote><p>rm -r project</p></blockquote><h2 id="Virtualenvwrapper"><a href="#Virtualenvwrapper" class="headerlink" title="Virtualenvwrapper"></a>Virtualenvwrapper</h2><ul><li>终端用fish的，使用virtualfish代替</li></ul><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><blockquote><p>pip install Virtualenvwrapper</p></blockquote><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><ul><li>export WORKON_HOME=‘~/.virtualenv’</li><li>Source /usr/local/bin/virtualenvwrapper.sh<ul><li>由于每次都需要执行这两步操作，可以将其写入终端的配置文件中。例如，如果使用 bash，则添加到 ~/.bashrc 中；如果使用 zsh，则添加到 ~/.zshrc 中。这样每次启动终端的时候都会自动运行，终端启动之后 virtualenvwrapper 就可以用了。</li></ul></li></ul><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><ul><li>这里创建的是系统默认的python版本的环境，用 which python 查看默认版本。 建议用下面的命令来制定版本。</li></ul><blockquote><p>$ mkvirtualenv spider              </p></blockquote><ul><li>指定建立3.4的python环境</li></ul><blockquote><p>$ mkvirtualenv -p /Users/heliclei/.localpython/bin/python3.4  env34     </p></blockquote><ul><li>指定建立2.7的python环境</li></ul><blockquote><p>$ mkvirtualenv -p /Users/heliclei/.localpython/bin/python2.7  env27 </p></blockquote><ul><li>进入：workon enve</li><li>离开：deactivate</li><li>删除：rmvirtualenv enve</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;virtualenv是什么&quot;&gt;&lt;a href=&quot;#virtualenv是什么&quot; class=&quot;headerlink&quot; title=&quot;virtualenv是什么&quot;&gt;&lt;/a&gt;virtualenv是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;virtualenv是一个工具，能够创建一个独立的python环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装使用&quot;&gt;&lt;a href=&quot;#安装使用&quot; class=&quot;headerlink&quot; title=&quot;安装使用&quot;&gt;&lt;/a&gt;安装使用&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;pip install virtualenv&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;1). 创建一个隔离的virtualenv环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;virtualenv project&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.yangqingwt.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>生成器-Generators</title>
    <link href="http://www.yangqingwt.top/2017/09/21/python%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8-Generators/"/>
    <id>http://www.yangqingwt.top/2017/09/21/python之生成器-Generators/</id>
    <published>2017-09-21T07:11:24.000Z</published>
    <updated>2017-10-23T08:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generators-生成器"><a href="#Generators-生成器" class="headerlink" title="Generators(生成器)"></a>Generators(生成器)</h2><ul><li>一种迭代器，但是只能对其迭代一次。<ul><li>因为它们并没有把所有的值存在内存中，而是在运行是生成值.</li></ul></li><li>通过遍历来使用<ul><li>“for”循环</li><li>传递转给任意可以进行迭代的函数和结构。（大多是以函数来实现）</li></ul></li><li>不返回一个值，而是yield一个值。</li></ul><a id="more"></a><p><img src="/img/python/generators/generators.png" alt=""></p><ul><li>生成器占很少的资源</li><li><p>eg:计算斐波那契数列的生成器：</p><ul><li>这种方式我们不用担心它会使用大量资源<br><img src="/img/python/generators/generators2.png" alt=""></li><li>这种方法也许会在计算很大的输入参数时，用尽所有的资源。<br><img src="/img/python/generators/generators3.png" alt=""><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4></li></ul><ul><li><p>允许获取序列的下一个元素<br><img src="/img/python/generators/generators4.png" alt=""></p></li><li><p>在yield所有值后，next（）触发了StopIteration的异常。但是在for循环时没有这个异常，因为for循环会自动捕捉到这个异常并停止调用next（）</p></li><li><p>python内置数据类型也支持迭代的<br><img src="/img/python/generators/generators5.png" alt=""></p><ul><li>str对象不是一个迭代器，它是一个可迭代对象。支持迭代，但不能直接对其进行迭代操作</li><li>对其实施迭代：使用iter,它将根据一个可迭代对象返回一个迭代器对象<br><img src="/img/python/generators/generators6.png" alt=""></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generators-生成器&quot;&gt;&lt;a href=&quot;#Generators-生成器&quot; class=&quot;headerlink&quot; title=&quot;Generators(生成器)&quot;&gt;&lt;/a&gt;Generators(生成器)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一种迭代器，但是只能对其迭代一次。&lt;ul&gt;
&lt;li&gt;因为它们并没有把所有的值存在内存中，而是在运行是生成值.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过遍历来使用&lt;ul&gt;
&lt;li&gt;“for”循环&lt;/li&gt;
&lt;li&gt;传递转给任意可以进行迭代的函数和结构。（大多是以函数来实现）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不返回一个值，而是yield一个值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.yangqingwt.top/categories/python/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>*args和\*\*kwargs</title>
    <link href="http://www.yangqingwt.top/2017/09/21/python%E4%B9%8B*args%E5%92%8C*kwargs/"/>
    <id>http://www.yangqingwt.top/2017/09/21/python之*args和*kwargs/</id>
    <published>2017-09-21T02:15:51.000Z</published>
    <updated>2017-09-21T07:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ul><li><p>它们主要用于函数定义，可以将不定数量的参数传递给一个函数</p><h2 id="args的用法"><a href="#args的用法" class="headerlink" title="*args的用法"></a>*args的用法</h2></li><li><p>*args是发送一个非键值对的可变数量的参数列表给一个函数</p></li><li>例：<img src="/img/python/args_kwargs/args.png" alt=""></li></ul><h2 id="kwargs的用法"><a href="#kwargs的用法" class="headerlink" title="**kwargs的用法"></a>**kwargs的用法</h2><ul><li><em>*kwargs允许将不定长度的键值对，作为参数传递给一个函数。如果想要在一个函数里处理带名字的参数，应该用\</em>*kwargs</li></ul><a id="more"></a><h2 id="使用args和-kwargs调用参数为列表或字典的函数"><a href="#使用args和-kwargs调用参数为列表或字典的函数" class="headerlink" title="使用args和\*kwargs调用参数为列表或字典的函数"></a>使用<em>args和\</em>*kwargs调用参数为列表或字典的函数</h2><p><img src="/img/python/args_kwargs/3.png" alt=""></p><ul><li>同时使用标准参数、*args与**kwargs时的顺序<blockquote><p>some_func(fargs, <em>args, \</em>*kwargs)</p></blockquote></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="最常见在写函数装饰器的时候用"><a href="#最常见在写函数装饰器的时候用" class="headerlink" title="最常见在写函数装饰器的时候用"></a>最常见在写函数装饰器的时候用</h4><h4 id="也可用来做猴子补丁"><a href="#也可用来做猴子补丁" class="headerlink" title="也可用来做猴子补丁"></a>也可用来做猴子补丁</h4><ul><li>猴子补丁：在程序运行是修改某些代码<ul><li>例：有一个类，里面有个叫get_info的函数会调用一个API并返回相应的数据。如果我们想测试它，可以把API调用替换成一些测试数据<blockquote><p>import someclass<br>def get_info(self, *args):<br>   return “Test data”<br>someclass.get_info = get_info</p></blockquote></li></ul></li></ul><p>摘自：<a href="https://github.com/eastlakeside/interpy-zh/blob/master/SUMMARY.md" target="_blank" rel="external">https://github.com/eastlakeside/interpy-zh/blob/master/SUMMARY.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它们主要用于函数定义，可以将不定数量的参数传递给一个函数&lt;/p&gt;
&lt;h2 id=&quot;args的用法&quot;&gt;&lt;a href=&quot;#args的用法&quot; class=&quot;headerlink&quot; title=&quot;*args的用法&quot;&gt;&lt;/a&gt;*args的用法&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;*args是发送一个非键值对的可变数量的参数列表给一个函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;例：&lt;img src=&quot;/img/python/args_kwargs/args.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kwargs的用法&quot;&gt;&lt;a href=&quot;#kwargs的用法&quot; class=&quot;headerlink&quot; title=&quot;**kwargs的用法&quot;&gt;&lt;/a&gt;**kwargs的用法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;*kwargs允许将不定长度的键值对，作为参数传递给一个函数。如果想要在一个函数里处理带名字的参数，应该用\&lt;/em&gt;*kwargs&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.yangqingwt.top/categories/python/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>scrapy</title>
    <link href="http://www.yangqingwt.top/2017/09/17/scrapy/"/>
    <id>http://www.yangqingwt.top/2017/09/17/scrapy/</id>
    <published>2017-09-17T13:54:38.000Z</published>
    <updated>2017-09-20T15:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
      <category term="爬虫" scheme="http://www.yangqingwt.top/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup</title>
    <link href="http://www.yangqingwt.top/2017/09/17/BeautifulSoup/"/>
    <id>http://www.yangqingwt.top/2017/09/17/BeautifulSoup/</id>
    <published>2017-09-17T13:00:53.000Z</published>
    <updated>2017-09-20T15:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install beautifulsoup4</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>导入    </p><p>  from bs4 import beautifulsoup</p></li><li><p>创建一个字符串    </p></li></ul><a id="more"></a><pre><code>html = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;    Once upon a time there were three little sisters; and their names were    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;    and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;</code></pre><ul><li><p>创建beautifulsoup对象</p><pre><code>soup = BeautifulSoup(html)</code></pre><ul><li><p>也可以用本地HTML文件来创建对象</p><pre><code>soup = BeautifulSoup(open(&apos;index.html&apos;))</code></pre></li></ul></li><li><p>格式化输出,打印出soup对象的内容</p><pre><code>print soup.prettify()</code></pre><p>  <img src="/img/python/爬虫/soup.png" alt=""></p></li></ul><h2 id="四大对象种类"><a href="#四大对象种类" class="headerlink" title="四大对象种类"></a>四大对象种类</h2><h3 id="1-Tag"><a href="#1-Tag" class="headerlink" title="1. Tag"></a>1. Tag</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><ul><li>是HTML中的一个个标签：title、 a等等HTML标签加上里面包括的内容<br>  <img src="/img/python/爬虫/soup_tag.png" alt=""></li><li><p>验证下这些对象的类型</p><pre><code>&gt;&gt;&gt; print type(soup.a)&lt;class &apos;bs4.element.Tag&apos;&gt;</code></pre></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><pre><code>&gt;&gt;&gt; print soup.name[document]&gt;&gt;&gt; print soup.head.namehead</code></pre><ul><li>suop对象本身比较特殊，它的 name 即为 [document]，对于其他内部标签，输出的值便为标签本身的名称。</li></ul><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><ul><li><p>把 p 的所有属性打印出来</p><pre><code>&gt;&gt;&gt; print soup.p.attrs{&apos;class&apos;: [&apos;title&apos;], &apos;name&apos;: &apos;dromouse&apos;}</code></pre></li><li><p>单独获取某个属性</p><pre><code>&gt;&gt;&gt; print soup.p[&apos;class&apos;][&apos;title&apos;]</code></pre></li><li><p>还可以用get方法</p><pre><code>&gt;&gt;&gt; print soup.p.get(&apos;class&apos;)[&apos;title&apos;]</code></pre></li><li><p>可以对这些属性和内容等等进行修改</p><pre><code>&gt;&gt;&gt; soup.p[&apos;class&apos;]=&quot;newClass&quot;&gt;&gt;&gt; print soup.p&lt;p class=&quot;newClass&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;    </code></pre></li><li><p>对这个属性进行删除</p><pre><code>&gt;&gt;&gt; del soup.p[&apos;class&apos;]&gt;&gt;&gt; print soup.p&lt;p name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</code></pre></li></ul><h3 id="2-NavigableString"><a href="#2-NavigableString" class="headerlink" title="2. NavigableString"></a>2. NavigableString</h3><h4 id="获取标签内部的文字"><a href="#获取标签内部的文字" class="headerlink" title="获取标签内部的文字"></a>获取标签内部的文字</h4><pre><code>&gt;&gt;&gt; print soup.p.stringThe Dormouse&apos;s story    </code></pre><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><pre><code>print type(soup.p.string)&lt;class &apos;bs4.element.NavigableString&apos;&gt;</code></pre><h3 id="3-BeautifulSoup"><a href="#3-BeautifulSoup" class="headerlink" title="3 BeautifulSoup"></a>3 BeautifulSoup</h3><ul><li>BeautifulSoup 对象表示的是一个文档的全部内容</li><li><p>大部分时候,可以把它当作 Tag 对象，是一个特殊的 Tag</p><pre><code>&gt;&gt;&gt; print type(soup.name)&lt;type &apos;unicode&apos;&gt;&gt;&gt;&gt; print soup.name [document]&gt;&gt;&gt; print soup.attrs {}         // 空字典</code></pre></li></ul><h3 id="4-comment"><a href="#4-comment" class="headerlink" title="4 comment"></a>4 comment</h3><ul><li>是一个特殊类型的 NavigableString 对象</li><li><p>其实输出的内容仍不包括注释符号    </p><pre><code>&gt;&gt;&gt; print soup.a&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;&gt;&gt;&gt; print soup.a.stringElsie &gt;&gt;&gt; print type(soup.a.string)&lt;class &apos;bs4.element.Comment&apos;&gt;</code></pre></li><li><p>a 里的内容实际上是注释，利用 .string 来输出它的内容，已经把注释符号去掉了( 所以这可能会给我们带来不必要的麻烦 )</p></li><li><p>在使用前最好做一下判断</p><pre><code>&gt;&gt;&gt; if type(soup.a.string)==bs4.element.Comment:...     print soup.a.string</code></pre></li></ul><h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><p>待续先，累了==</p><p><br></p><p>摘自： <a href="http://python.jobbole.com/81349/" target="_blank" rel="external">http://python.jobbole.com/81349/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装和使用&quot;&gt;&lt;a href=&quot;#安装和使用&quot; class=&quot;headerlink&quot; title=&quot;安装和使用&quot;&gt;&lt;/a&gt;安装和使用&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;pip install beautifulsoup4
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;导入    &lt;/p&gt;
&lt;p&gt;  from bs4 import beautifulsoup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个字符串    &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://www.yangqingwt.top/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>itertools</title>
    <link href="http://www.yangqingwt.top/2017/09/17/python%E4%B9%8Bitertools/"/>
    <id>http://www.yangqingwt.top/2017/09/17/python之itertools/</id>
    <published>2017-09-17T09:26:27.000Z</published>
    <updated>2017-09-20T15:06:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python的内建模块itertools：提供了一些用于操作迭代对象的函数"><a href="#python的内建模块itertools：提供了一些用于操作迭代对象的函数" class="headerlink" title="python的内建模块itertools：提供了一些用于操作迭代对象的函数"></a>python的内建模块itertools：提供了一些用于操作迭代对象的函数</h2><h3 id="“无限”迭代器"><a href="#“无限”迭代器" class="headerlink" title="“无限”迭代器"></a>“无限”迭代器</h3><pre><code>&gt;&gt;&gt; import itertools </code></pre><h4 id="count（）：会创建一个无限迭代器"><a href="#count（）：会创建一个无限迭代器" class="headerlink" title="count（）：会创建一个无限迭代器"></a>count（）：会创建一个无限迭代器</h4><pre><code>&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; for n in natuals:...     print n123...</code></pre><h4 id="cycle-会把传入的序列无限重复下去"><a href="#cycle-会把传入的序列无限重复下去" class="headerlink" title="cycle(): 会把传入的序列无限重复下去"></a>cycle(): 会把传入的序列无限重复下去</h4><a id="more"></a><pre><code>&gt;&gt;&gt; cs = itertools.cycle(&quot;abc&quot;)&gt;&gt;&gt; for c in cs:...        print c...&apos;a&apos;&apos;b&apos;&apos;c&apos;&apos;a&apos;...</code></pre><h4 id="repeat-把一个元素无限重复，第二个参数可以限定重复额次数"><a href="#repeat-把一个元素无限重复，第二个参数可以限定重复额次数" class="headerlink" title="repeat() 把一个元素无限重复，第二个参数可以限定重复额次数"></a>repeat() 把一个元素无限重复，第二个参数可以限定重复额次数</h4><pre><code>&gt;&gt;&gt; ns = itertools.repeat(&apos;a&apos;, 10)&gt;&gt;&gt; for n in ns:...        print n...打印10次&apos;a&apos;</code></pre><h3 id="迭代器操作函数"><a href="#迭代器操作函数" class="headerlink" title="迭代器操作函数"></a>迭代器操作函数</h3><h4 id="chain（）：把一组迭代对象串联起来，形成大的迭代器"><a href="#chain（）：把一组迭代对象串联起来，形成大的迭代器" class="headerlink" title="chain（）：把一组迭代对象串联起来，形成大的迭代器"></a>chain（）：把一组迭代对象串联起来，形成大的迭代器</h4><pre><code>&gt;&gt;&gt; for c in itertools.chain(&apos;abc&apos;, &apos;def&apos;):...        print c...&apos;a&apos;&apos;b&apos;&apos;c&apos;&apos;d&apos;&apos;e&apos;&apos;f&apos;</code></pre><h4 id="groupby-把迭代器中相邻的重复元素挑出来放在一起"><a href="#groupby-把迭代器中相邻的重复元素挑出来放在一起" class="headerlink" title="groupby(): 把迭代器中相邻的重复元素挑出来放在一起"></a>groupby(): 把迭代器中相邻的重复元素挑出来放在一起</h4><pre><code>&gt;&gt;&gt; for key, group in itertools.groupby(&apos;aabbcccaa&apos;):...     print key, list(group)...a [&apos;a&apos;, &apos;a&apos;]b [&apos;b&apos;, &apos;b&apos;]c [&apos;c&apos;, &apos;c&apos;, &apos;c&apos;]a [&apos;a&apos;, &apos;a&apos;]</code></pre><ul><li><p>可以添加调选规则</p><pre><code>让‘A’和‘a’都返回相同的key：&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AaaBBbcCaAa&apos;, lambda c: c.upper()):...     print key, list(group)...A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;]B [&apos;B&apos;, &apos;B&apos;, &apos;b&apos;]C [&apos;c&apos;, &apos;C&apos;]A [&apos;a&apos;, &apos;A&apos;, &apos;a&apos;]</code></pre><h4 id="imap-可以作用与无穷序列，如果两个序列长度不一致，以短的为准"><a href="#imap-可以作用与无穷序列，如果两个序列长度不一致，以短的为准" class="headerlink" title="imap(): 可以作用与无穷序列，如果两个序列长度不一致，以短的为准"></a>imap(): 可以作用与无穷序列，如果两个序列长度不一致，以短的为准</h4><pre><code>&gt;&gt;&gt; for x in itertools.imap(lambda x, y: x * y, [10, 20, 30], itertools.count(1)):...     print x...104090    </code></pre></li><li>imap()返回一个迭代对象，必须用for循环进行迭代，才会在循环中计算出下一个元素</li><li><p>map() 返回list，调用它试，已经计算完毕</p><pre><code>&gt;&gt;&gt; r = map(lambda x: x*x, [1, 2, 3])&gt;&gt;&gt; r         # r已经计算出来了[1, 4, 9]</code></pre></li><li>imap()实现了“惰性计算”，只在需要获得结果时才计算<h4 id="ifilter-fileter的惰性实现"><a href="#ifilter-fileter的惰性实现" class="headerlink" title="ifilter: fileter的惰性实现"></a>ifilter: fileter的惰性实现</h4></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>itertools提供的全是处理迭代功能的函数，返回值是迭代对象，只有用for循环迭代试才真正计算        </li></ul><p><br><br><br><br>参考资源：<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001415616001996f6b32d80b6454caca3d33c965a07611f000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001415616001996f6b32d80b6454caca3d33c965a07611f000</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python的内建模块itertools：提供了一些用于操作迭代对象的函数&quot;&gt;&lt;a href=&quot;#python的内建模块itertools：提供了一些用于操作迭代对象的函数&quot; class=&quot;headerlink&quot; title=&quot;python的内建模块itertools：提供了一些用于操作迭代对象的函数&quot;&gt;&lt;/a&gt;python的内建模块itertools：提供了一些用于操作迭代对象的函数&lt;/h2&gt;&lt;h3 id=&quot;“无限”迭代器&quot;&gt;&lt;a href=&quot;#“无限”迭代器&quot; class=&quot;headerlink&quot; title=&quot;“无限”迭代器&quot;&gt;&lt;/a&gt;“无限”迭代器&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import itertools 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;count（）：会创建一个无限迭代器&quot;&gt;&lt;a href=&quot;#count（）：会创建一个无限迭代器&quot; class=&quot;headerlink&quot; title=&quot;count（）：会创建一个无限迭代器&quot;&gt;&lt;/a&gt;count（）：会创建一个无限迭代器&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; natuals = itertools.count(1)
&amp;gt;&amp;gt;&amp;gt; for n in natuals:
...     print n
1
2
3
...
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;cycle-会把传入的序列无限重复下去&quot;&gt;&lt;a href=&quot;#cycle-会把传入的序列无限重复下去&quot; class=&quot;headerlink&quot; title=&quot;cycle(): 会把传入的序列无限重复下去&quot;&gt;&lt;/a&gt;cycle(): 会把传入的序列无限重复下去&lt;/h4&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.yangqingwt.top/categories/python/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://www.yangqingwt.top/2017/09/16/nginx/"/>
    <id>http://www.yangqingwt.top/2017/09/16/nginx/</id>
    <published>2017-09-16T08:09:58.000Z</published>
    <updated>2018-04-21T08:54:26.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h2><p>nginx是服务器软件</p><p>功能：</p><ul><li>可以与服务器硬件结构，将程序放在nginx服务器上，将程序发布出去</li><li>作用：<ul><li>高性能的HTTP：发布网站</li><li>反向代理服务器：实现负载均衡</li><li>代理邮件服务器：收发邮件</li></ul></li><li>优点：<ul><li>高并发、部署简单、内存消耗少、成本低</li></ul></li><li>缺点：<ul><li>rewrite功能不够强大</li><li>模块没有Apache多</li></ul></li></ul><a id="more"></a><ul><li>补充知识：<ul><li>负载均衡：当同时又很多用户访问服务器时，为减少服务器压力，需要将用户分别引入各服务器，分担服务器的压力。</li></ul></li></ul><h3 id="不同服务器的优缺点："><a href="#不同服务器的优缺点：" class="headerlink" title="不同服务器的优缺点："></a>不同服务器的优缺点：</h3><ul><li>IIS：IIS服务器只能在Windows上运行，Windows服务器性能不如Linux一类服务器</li><li>Tomcat：面向Java，是一种重量级服务器</li><li>Nginx：轻量级，但能支持处理百万级的TCP连接，10万以上的并发连接，并且是一个很好的跨平台服务器</li><li>Apache：稳定、开源、跨平台，但不支持高并发</li></ul><h3 id="在Linux安装nginx服务器"><a href="#在Linux安装nginx服务器" class="headerlink" title="在Linux安装nginx服务器"></a>在Linux安装nginx服务器</h3><ul><li>进入终端</li><li><p>安装nginx</p><ol><li><p>下载nginx安装包：</p><pre><code>wget http://nginx.org/download/nginx-1.6.2.tar.gz </code></pre></li><li><p>解压：</p><pre><code>tar zxvf nginx-1.6.2cd nginx-1.6.2</code></pre></li><li><p>编译：</p><p> make<br> make install</p></li></ol></li><li><p>运行：</p><pre><code>/usr/local/bin/nginx</code></pre><ul><li>-s reload 重新载入配置文件</li><li>-s reopen 重启nginx</li><li>-s stop 停止nginx</li></ul></li><li><p>路径:</p><ul><li>配置所在路径：usr/local/etc/nginx</li><li>运行程序所在路径：/usr/local/bin</li></ul></li><li><p>配置:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">user yangq4 staff; </div><div class="line"># 启动进程，通常设置成和CPU的数量相等</div><div class="line">worker_processes  1;</div><div class="line"></div><div class="line"># 全局错误日志</div><div class="line"># error_log  logs/error.log;</div><div class="line"># error_log  logs/error.log  notice;</div><div class="line"># error_log  logs/error.log  info;</div><div class="line"></div><div class="line"># 记录当前启动的NGINX的进程ID</div><div class="line"># pid        logs/nginx.pid;</div><div class="line"></div><div class="line"># 工作模式及连接数上限</div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;   # 单个后台进程的最大并发链接数</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line"></div><div class="line"># access_log  logs/access.log  main;</div><div class="line">    rewrite_log  on;</div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line">    keepalive_timeout  120;</div><div class="line">    tcp_nopush     on;</div><div class="line"></div><div class="line">    #gzip  on;</div><div class="line"></div><div class="line">    # 设定实际的服务器列表</div><div class="line">    upstream zp_server1&#123;</div><div class="line">        server 127.0.0.1:8090;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    # HTTP服务器</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  www.yangq4_test.com;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            # root   /Users/boleng/Desktop/W3E/src/frontend;</div><div class="line">            root   /Users/yangqing/Desktop/test/api.py;</div><div class="line">            index  index.html index.html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        charset utf-8;</div><div class="line"></div><div class="line"># 代理配置参数</div><div class="line">        proxy_connect_timeout 180;</div><div class="line">        proxy_send_timeout 180;</div><div class="line">        proxy_read_timeout 180;</div><div class="line">        proxy_set_header Host $host;</div><div class="line">        proxy_set_header X-Forwarder-For $remote_addr;</div><div class="line"></div><div class="line">        #error_page  404              /404.html;</div><div class="line"></div><div class="line">        # redirect server error pages to the static page /50x.html</div><div class="line">        #</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是nginx&quot;&gt;&lt;a href=&quot;#什么是nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是nginx&quot;&gt;&lt;/a&gt;什么是nginx&lt;/h2&gt;&lt;p&gt;nginx是服务器软件&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以与服务器硬件结构，将程序放在nginx服务器上，将程序发布出去&lt;/li&gt;
&lt;li&gt;作用：&lt;ul&gt;
&lt;li&gt;高性能的HTTP：发布网站&lt;/li&gt;
&lt;li&gt;反向代理服务器：实现负载均衡&lt;/li&gt;
&lt;li&gt;代理邮件服务器：收发邮件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：&lt;ul&gt;
&lt;li&gt;高并发、部署简单、内存消耗少、成本低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：&lt;ul&gt;
&lt;li&gt;rewrite功能不够强大&lt;/li&gt;
&lt;li&gt;模块没有Apache多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.yangqingwt.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="nginx" scheme="http://www.yangqingwt.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>python之编码</title>
    <link href="http://www.yangqingwt.top/2017/09/13/python%E4%B9%8B%E7%BC%96%E7%A0%81/"/>
    <id>http://www.yangqingwt.top/2017/09/13/python之编码/</id>
    <published>2017-09-13T08:26:57.000Z</published>
    <updated>2017-09-20T15:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="decode-和-encode"><a href="#decode-和-encode" class="headerlink" title="decode 和 encode"></a>decode 和 encode</h2><p> 字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即：先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</p><ul><li><p>decode: 将其他编码的字符解码成Unicode编码</p><blockquote><p>strs.decode(‘gb2312’) 将gb2312编码的字符串strs转换成Unicode</p></blockquote></li><li><p>encode：将Unicode编码转换成其他编码的字符串</p><blockquote><p>strs.encode(‘gb2312’) 将Unicode编码的字符串strs转换成gb2312编码</p><ul><li>非Unicode编码的strs字符串encode会报错</li></ul></blockquote></li></ul><a id="more"></a><h2 id="判断是否为unicode"><a href="#判断是否为unicode" class="headerlink" title="判断是否为unicode"></a>判断是否为unicode</h2><blockquote><p>isinstance(strs, unicode)</p></blockquote><p>原文链接：<a href="http://cache.baiducontent.com/c?m=9d78d513d99516fe05bbc3690d67952d5f0edd3f2890904b708ed50ed1735a325a7bb3e57a770704a4943d315db8492bb6a7706f700123b799cf884ad9b18f7b6fce7c652e4b9b1745954af4950738c4239358eaaa19e4&amp;p=c663d115d9c342ac17add72d021481&amp;newp=81769a4795934eaf5beec62159578f231610db2151ddd301298ffe0cc4241a1a1a3aecbf2126130fd5ce7e6c07a54b5ae0f63c76310034f1f689df08d2ecce7e6c&amp;user=baidu&amp;fm=sc&amp;query=decode+python&amp;qid=ed9a1561000147fe&amp;p1=5" target="_blank" rel="external">http://cache.baiducontent.com/c?m=9d78d513d99516fe05bbc3690d67952d5f0edd3f2890904b708ed50ed1735a325a7bb3e57a770704a4943d315db8492bb6a7706f700123b799cf884ad9b18f7b6fce7c652e4b9b1745954af4950738c4239358eaaa19e4&amp;p=c663d115d9c342ac17add72d021481&amp;newp=81769a4795934eaf5beec62159578f231610db2151ddd301298ffe0cc4241a1a1a3aecbf2126130fd5ce7e6c07a54b5ae0f63c76310034f1f689df08d2ecce7e6c&amp;user=baidu&amp;fm=sc&amp;query=decode+python&amp;qid=ed9a1561000147fe&amp;p1=5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;decode-和-encode&quot;&gt;&lt;a href=&quot;#decode-和-encode&quot; class=&quot;headerlink&quot; title=&quot;decode 和 encode&quot;&gt;&lt;/a&gt;decode 和 encode&lt;/h2&gt;&lt;p&gt; 字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即：先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;decode: 将其他编码的字符解码成Unicode编码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;strs.decode(‘gb2312’) 将gb2312编码的字符串strs转换成Unicode&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;encode：将Unicode编码转换成其他编码的字符串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;strs.encode(‘gb2312’) 将Unicode编码的字符串strs转换成gb2312编码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非Unicode编码的strs字符串encode会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.yangqingwt.top/categories/python/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>调试</title>
    <link href="http://www.yangqingwt.top/2017/09/13/python%E4%B9%8Bpdb/"/>
    <id>http://www.yangqingwt.top/2017/09/13/python之pdb/</id>
    <published>2017-09-13T08:01:54.000Z</published>
    <updated>2017-09-21T07:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从脚本内部运行"><a href="#从脚本内部运行" class="headerlink" title="从脚本内部运行"></a>从脚本内部运行</h2><h3 id="引入pdb模块"><a href="#引入pdb模块" class="headerlink" title="引入pdb模块"></a>引入pdb模块</h3><blockquote><p>import pdb</p><p>pdb.set_trace()</p></blockquote><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><ul><li>b / break: 设置断点</li><li>c / continue: 继续执行程序</li><li>l / list: 查看当前的代码段</li><li>s / step: 进入函数</li><li>r / return: 执行代码直到从当前函数返回</li></ul><a id="more"></a><ul><li>n / next: 执行下一行</li><li>q / exit: 中止并退出</li><li>p / pp: 打印变量的值</li><li>h / help: 帮助</li><li>w: 显示当前正在执行的代码行的上下文信息</li></ul><h2 id="从命令行运行"><a href="#从命令行运行" class="headerlink" title="从命令行运行"></a>从命令行运行</h2><ul><li>在命令行使用Python debugger运行一个脚本</li></ul><blockquote><p>python -m pdb test.py</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从脚本内部运行&quot;&gt;&lt;a href=&quot;#从脚本内部运行&quot; class=&quot;headerlink&quot; title=&quot;从脚本内部运行&quot;&gt;&lt;/a&gt;从脚本内部运行&lt;/h2&gt;&lt;h3 id=&quot;引入pdb模块&quot;&gt;&lt;a href=&quot;#引入pdb模块&quot; class=&quot;headerlink&quot; title=&quot;引入pdb模块&quot;&gt;&lt;/a&gt;引入pdb模块&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;import pdb&lt;/p&gt;
&lt;p&gt;pdb.set_trace()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;命令列表&quot;&gt;&lt;a href=&quot;#命令列表&quot; class=&quot;headerlink&quot; title=&quot;命令列表&quot;&gt;&lt;/a&gt;命令列表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;b / break: 设置断点&lt;/li&gt;
&lt;li&gt;c / continue: 继续执行程序&lt;/li&gt;
&lt;li&gt;l / list: 查看当前的代码段&lt;/li&gt;
&lt;li&gt;s / step: 进入函数&lt;/li&gt;
&lt;li&gt;r / return: 执行代码直到从当前函数返回&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="调试" scheme="http://www.yangqingwt.top/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>电脑配置</title>
    <link href="http://www.yangqingwt.top/2017/09/06/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.yangqingwt.top/2017/09/06/电脑配置/</id>
    <published>2017-09-06T13:48:27.000Z</published>
    <updated>2017-09-20T15:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>看图吧先<br><img src="/img/电脑配置/center.png" alt=""></p><ol><li>CPU（处理器）<ul><li>inter：酷睿i3、酷睿i5、酷睿i7<ul><li>i5 5200U：中端处理器，第五代，编号200<img src="/img/电脑配置/computer.png" alt=""></li></ul></li><li>ADM</li><li>概述：<ul><li>i3：普通办公</li><li>i5：玩网游</li><li>i7：性能好，价格高。同时高耗能造成高发热</li></ul></li></ul></li><li>内存：可以自己更换（少数，如Mac、Surface等超薄的，内存条焊在主板上，无法自己更换）</li></ol><a id="more"></a><ol><li><p>显卡：（N卡：英伟达公司的，GT开头；A卡：AMD公司的)</p><ul><li>分为两种<ul><li>双显卡：独立显卡+核心显卡</li><li>核心显卡电脑</li></ul></li><li>根据型号判断显卡性能</li><li>独立显卡：<ul><li>通常显卡型号为GT abcM（abc为数字）<ul><li>a代表是第几代产品</li><li>bc为它的型号，b代表显卡的定位，5定位为中端，大于5高端，小于5为入门级别</li><li>末尾M代表它四笔记本电脑显卡</li><li>有的在GT后添加x，代表更好的性能</li><li>例：GT820M，第八代入门级别的笔记本显卡</li></ul></li></ul></li><li>核心显卡：<ul><li>理解为集成显卡，它把图形处理核心整合在了CPU当中</li><li>双显卡，在游戏等需要较大图形运算量时，才会自动切换为<strong>独立显卡</strong>，所以双显卡性能取决于其中高性能显卡所能达到的性能（一般是独立显卡）</li><li>HD4400, HD4600 &lt; HD5500, HD5600 &lt; HD6000 &lt; HD520, HD530 &lt; HD5100,HD540,HD550 &lt; HD6100 &lt; HD5200 &lt; HD6200</li><li>目前最好的HD6200的显卡大概是中端独立显卡性能水平。</li></ul></li></ul></li><li><p>硬盘：电脑的存储设备</p></li><li>主板：结合CPU、显卡、硬盘等综合考虑</li><li>台式机：还需注意：风扇、散热器、显示器</li></ol><p>摘自：<a href="https://www.zhihu.com/question/40463573/answer/87720343" target="_blank" rel="external">https://www.zhihu.com/question/40463573/answer/87720343</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础配置&quot;&gt;&lt;a href=&quot;#基础配置&quot; class=&quot;headerlink&quot; title=&quot;基础配置&quot;&gt;&lt;/a&gt;基础配置&lt;/h2&gt;&lt;p&gt;看图吧先&lt;br&gt;&lt;img src=&quot;/img/电脑配置/center.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU（处理器）&lt;ul&gt;
&lt;li&gt;inter：酷睿i3、酷睿i5、酷睿i7&lt;ul&gt;
&lt;li&gt;i5 5200U：中端处理器，第五代，编号200&lt;img src=&quot;/img/电脑配置/computer.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ADM&lt;/li&gt;
&lt;li&gt;概述：&lt;ul&gt;
&lt;li&gt;i3：普通办公&lt;/li&gt;
&lt;li&gt;i5：玩网游&lt;/li&gt;
&lt;li&gt;i7：性能好，价格高。同时高耗能造成高发热&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存：可以自己更换（少数，如Mac、Surface等超薄的，内存条焊在主板上，无法自己更换）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.yangqingwt.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="电脑配置" scheme="http://www.yangqingwt.top/tags/%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>SmallSentiment</title>
    <link href="http://www.yangqingwt.top/2017/09/05/SmallSentiment/"/>
    <id>http://www.yangqingwt.top/2017/09/05/SmallSentiment/</id>
    <published>2017-09-05T09:26:47.000Z</published>
    <updated>2017-09-20T15:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python之pandas</title>
    <link href="http://www.yangqingwt.top/2017/08/31/python%E4%B9%8Bpandas/"/>
    <id>http://www.yangqingwt.top/2017/08/31/python之pandas/</id>
    <published>2017-08-31T15:50:12.000Z</published>
    <updated>2017-09-20T15:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础整理"><a href="#基础整理" class="headerlink" title="基础整理"></a>基础整理</h1><ul><li>数据量达到亿的时候，可以用pandas处理</li><li><p>导入pandas库</p><blockquote><p>import pandas as pd<br>import numpy as np</p></blockquote></li><li><p>导入数据</p><ol><li>pd.read_csv(filename)：从CSV文件导入数据</li><li>pd.read_table(filename)：从限定分隔符的文本文件导入数据</li><li>pd.read_excel(filename)：从Excel文件导入数据</li><li>pd.read_sql(query, connection_object)：从SQL表/库导入数据</li><li>pd.read_json(json_string)：从JSON格式的字符串导入数据</li></ol></li></ul><a id="more"></a><pre><code>6. pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格7. pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()8. pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据</code></pre><ul><li><p>导出数据</p><ol><li>df.to_csv(filename)：导出数据到CSV文件</li><li>df.to_excel(filename)：导出数据到Excel文件</li><li>df.to_sql(table_name, connection_object)：导出数据到SQL表</li><li>df.to_json(filename)：以Json格式导出数据到文本文件</li></ol></li><li><p>创建测试对象</p><ol><li>pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象</li><li>pd.Series(my_list)：从可迭代对象my_list创建一个Series对象</li><li>df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引</li></ol></li><li><p>查看、检查数据</p><ol><li>df.head(n)：查看DataFrame对象的前n行</li><li>df.tail(n)：查看DataFrame对象的最后n行</li><li>df.shape()：查看行数和列数</li><li>df.info() ：查看索引、数据类型和内存信息</li><li>df.describe()：查看数值型列的汇总统计</li><li>s.value_counts(dropna=False)：查看Series对象的唯一值和计数</li><li>df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</li></ol></li><li><p>数据选取</p><ol><li>df[col]：根据列名，并以Series的形式返回列</li><li>df[[col1, col2]]：以DataFrame形式返回多列</li><li>s.iloc[0]：按位置选取数据</li><li>s.loc[‘index_one’]：按索引选取数据</li><li>df.iloc[0,:]：返回第一行</li><li>df.iloc[0,0]：返回第一列的第一个元素</li></ol></li><li><p>数据清理</p><ol><li>df.columns = [‘a’,’b’,’c’]：重命名列名</li><li>pd.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组</li><li>pd.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组</li><li>df.dropna()：删除所有包含空值的行</li><li>df.dropna(axis=1)：删除所有包含空值的列</li><li>df.dropna(axis=1,thresh=n)：删除所有小于n个非空值的行</li><li>df.fillna(x)：用x替换DataFrame对象中所有的空值</li><li>s.astype(float)：将Series中的数据类型更改为float类型</li><li>s.replace(1,’one’)：用‘one’代替所有等于1的值</li><li>s.replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替</li><li>df.rename(columns=lambda x: x + 1)：批量更改列名</li><li>df.rename(columns={‘old<em>name’: ‘new</em> name’})：选择性更改列名</li><li>df.set_index(‘column_one’)：更改索引列</li><li>df.rename(index=lambda x: x + 1)：批量重命名索引</li></ol></li><li><p>数据处理：Filter、Sort和GroupBy</p><ol><li>df[df[col] &gt; 0.5]：选择col列的值大于0.5的行</li><li>df.sort_values(col1)：按照列col1排序数据，默认升序排列</li><li>df.sort_values(col2, ascending=False)：按照列col1降序排列数据</li><li>df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据</li><li>df.groupby(col)：返回一个按列col进行分组的Groupby对象</li><li>df.groupby([col1,col2])：返回一个按多列进行分组的Groupby对象</li><li>df.groupby(col1)[col2]：返回按列col1进行分组后，列col2的均值</li><li>df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表</li><li>df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值</li><li>data.apply(np.mean)：对DataFrame中的每一列应用函数np.mean</li><li>data.apply(np.max,axis=1)：对DataFrame中的每一行应用函数np.max</li></ol></li><li><p>数据合并</p><ol><li>df1.append(df2)：将df2中的行添加到df1的尾部</li><li>df.concat([df1, df2],axis=1)：将df2中的列添加到df1的尾部</li><li>df1.join(df2,on=col1,how=’inner’)：对df1的列和df2的列执行SQL形式的join</li></ol></li><li><p>数据统计</p><ol><li>df.describe()：查看数据值列的汇总统计</li><li>df.mean()：返回所有列的均值</li><li>df.corr()：返回列与列之间的相关系数</li><li>df.count()：返回每一列中的非空值的个数</li><li>df.max()：返回每一列的最大值</li><li>df.min()：返回每一列的最小值</li><li>df.median()：返回每一列的中位数</li><li>df.std()：返回每一列的标准差</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础整理&quot;&gt;&lt;a href=&quot;#基础整理&quot; class=&quot;headerlink&quot; title=&quot;基础整理&quot;&gt;&lt;/a&gt;基础整理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据量达到亿的时候，可以用pandas处理&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入pandas库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;import pandas as pd&lt;br&gt;import numpy as np&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pd.read_csv(filename)：从CSV文件导入数据&lt;/li&gt;
&lt;li&gt;pd.read_table(filename)：从限定分隔符的文本文件导入数据&lt;/li&gt;
&lt;li&gt;pd.read_excel(filename)：从Excel文件导入数据&lt;/li&gt;
&lt;li&gt;pd.read_sql(query, connection_object)：从SQL表/库导入数据&lt;/li&gt;
&lt;li&gt;pd.read_json(json_string)：从JSON格式的字符串导入数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://www.yangqingwt.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://www.yangqingwt.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sublime</title>
    <link href="http://www.yangqingwt.top/2017/08/31/sublime/"/>
    <id>http://www.yangqingwt.top/2017/08/31/sublime/</id>
    <published>2017-08-31T03:03:29.000Z</published>
    <updated>2017-09-20T15:11:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>command + D 选中光标所在词，多次操作</li><li>command + L 选中整行</li><li>command + shift + L 先选中多行，再按快捷键，会在每行行尾有光标，同时编辑</li><li>ctrl + M 光标移动至括号首尾</li><li>command + 回车 在下行插入新行</li><li>command + shift + 回车 在上行插入新行</li><li>command + &lt;- 向左单位性的移动光标</li><li>command + -&gt; 向右快速移动光标</li><li>shift + 方向键 选中文本</li><li>command + shift + 方向键 单位性的选中文本</li></ul><a id="more"></a><ul><li>command + shift + d 复制当前行，插入到下一行</li><li>command + K + K 光标处删除至行尾（ctrl+k）</li><li>ctrl + shift + K 删除整行</li><li>command + K + U 词转换为大写</li><li>command + K + L 转换为小写</li><li>ctrl + T 左右字母互换</li><li>command + alt + F 搜索+替换</li><li>ctrl + tab 切换标签页</li><li>command + K + B 开启/关闭侧边栏</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;command + D 选中光标所在词，多次操作&lt;/li&gt;
&lt;li&gt;command + L 选中整行&lt;/li&gt;
&lt;li&gt;command + shift + L 先选中多行，再按快捷键，会在每行行尾有光标，同时编辑&lt;/li&gt;
&lt;li&gt;ctrl + M 光标移动至括号首尾&lt;/li&gt;
&lt;li&gt;command + 回车 在下行插入新行&lt;/li&gt;
&lt;li&gt;command + shift + 回车 在上行插入新行&lt;/li&gt;
&lt;li&gt;command + &amp;lt;- 向左单位性的移动光标&lt;/li&gt;
&lt;li&gt;command + -&amp;gt; 向右快速移动光标&lt;/li&gt;
&lt;li&gt;shift + 方向键 选中文本&lt;/li&gt;
&lt;li&gt;command + shift + 方向键 单位性的选中文本&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="IDE" scheme="http://www.yangqingwt.top/categories/IDE/"/>
    
    
      <category term="sublime" scheme="http://www.yangqingwt.top/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>js</title>
    <link href="http://www.yangqingwt.top/2017/08/31/js/"/>
    <id>http://www.yangqingwt.top/2017/08/31/js/</id>
    <published>2017-08-31T02:39:00.000Z</published>
    <updated>2017-09-20T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>注释 行注释//  段注释/<em> </em>/</li><li>== 会自动转换类型，一致后再比较</li><li>=== 不会自动转换类型，类型不一致返回false</li><li>NaN 与所有值都不相等，包括自己<blockquote><p>NaN === NaN; //false<br>用isNaN()函数判断<br>isNaN（NaN）; //true</p></blockquote></li><li>null：表示空的值（与python的None类似 ）</li><li>undefined: 表示未定义，在判断函数参数是否传递的情况下有用</li><li>变量名：大小写英文、数字、$和_的组合</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;注释 行注释//  段注释/&lt;em&gt; &lt;/em&gt;/&lt;/li&gt;
&lt;li&gt;== 会自动转换类型，一致后再比较&lt;/li&gt;
&lt;li&gt;=== 不会自动转换类型，类型不一致返回false&lt;/li&gt;
&lt;li&gt;NaN 与所有值都不相等，包括自己&lt;blockquote&gt;
&lt;p&gt;NaN === NaN; //false&lt;br&gt;用isNaN()函数判断&lt;br&gt;isNaN（NaN）; //true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;null：表示空的值（与python的None类似 ）&lt;/li&gt;
&lt;li&gt;undefined: 表示未定义，在判断函数参数是否传递的情况下有用&lt;/li&gt;
&lt;li&gt;变量名：大小写英文、数字、$和_的组合&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.yangqingwt.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="http://www.yangqingwt.top/tags/js/"/>
    
  </entry>
  
</feed>
